<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Camera Stream (MediaRecorder)</title>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; margin: 16px; }
    .row { display: flex; gap: 8px; flex-wrap: wrap; align-items: center; margin-bottom: 12px; }
    button, select { padding: 8px 12px; border-radius: 10px; border: 1px solid #ddd; }
    #preview { width: 100%; max-width: 720px; background: #000; border-radius: 12px; }
    .mirror { transform: scaleX(-1); }
    .pill { padding: 4px 8px; border-radius: 999px; font-size: 12px; background:#f2f2f2; }
    .warn { color: #b10f2e; font-weight: 600; }
  </style>
</head>
<body>
  <h2>ì¹´ë©”ë¼ ì „ì†¡ (640Ã—360, 24fps ëª©í‘œ)</h2>

  <div class="row">
    <button id="btnStartCam">ì¹´ë©”ë¼ ì‹œì‘</button>
    <button id="btnFront">ì „ë©´</button>
    <button id="btnBack">í›„ë©´</button>
    <select id="selDevice"></select>
    <span class="pill" id="labCamInfo">-</span>
  </div>

  <div class="row">
    <button id="btnStartStream">ìŠ¤íŠ¸ë¦¬ë° ì‹œì‘</button>
    <button id="btnStopStream" disabled>ìŠ¤íŠ¸ë¦¬ë° ì¤‘ì§€</button>
    <span class="pill">ëª©í‘œ fps: 24</span>
    <span class="pill" id="labWs">WS: -</span>
    <span class="pill" id="labBuf">buffered: 0</span>
  </div>

  <video id="preview" autoplay playsinline muted></video>
  <canvas id="canvas" hidden></canvas>

  <p id="httpsHint" class="warn"></p>

  <script>
    let stream = null;
    let track = null;
    let rec = null;
    let ws = null;
    let currentFacing = 'user'; // 'user' | 'environment'
    let currentExt = 'mp4';     // iOS ê¸°ë³¸ ê°€ì •(mp4/h264), í¬ë¡¬ì€ webmë¡œ ë°”ë€œ
    let sid = 'cam1';

    const $ = (id) => document.getElementById(id);
    const $preview = $('preview');
    const $labCamInfo = $('labCamInfo');
    const $selDevice = $('selDevice');
    const $labWs = $('labWs');
    const $labBuf = $('labBuf');
    const $httpsHint = $('httpsHint');

    // HTTPS ì²´í¬(iOSëŠ” ì‹ ë¢°ëœ ì¸ì¦ì„œ í•„ìš”)
    // (function checkHttps(){
    //   if (location.protocol !== 'https:' && location.hostname !== 'localhost') {
    //     $httpsHint.textContent = 'iOS Safariì—ì„œëŠ” HTTPS(ì‹ ë¢°ëœ ì¸ì¦ì„œ)ê°€ ì•„ë‹ˆë©´ ì¹´ë©”ë¼/ë…¹í™”ê°€ ë™ì‘í•˜ì§€ ì•Šì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.';
    //   }
    // })();
    // ê°œë°œìš© HTTP ì„œë²„ì´ë¯€ë¡œ ê²½ê³ ëŠ” í‘œì‹œí•˜ì§€ ì•ŠìŒ(í•„ìš” ì‹œ ë˜ì‚´ë¦¬ì„¸ìš”)
    (function(){})();

    function pickMime() {
      // iOS SafariëŠ” mp4/h264 ì„ í˜¸, í¬ë¡¬/ì•ˆë“œë¡œì´ë“œëŠ” webm/vp8 ì„ í˜¸
      if (MediaRecorder.isTypeSupported('video/mp4;codecs=h264')) { currentExt = 'mp4'; return 'video/mp4;codecs=h264'; }
      if (MediaRecorder.isTypeSupported('video/webm;codecs=vp8')) { currentExt = 'webm'; return 'video/webm;codecs=vp8'; }
      // ë§ˆì§€ë§‰ í´ë°±
      currentExt = 'webm';
      return '';
    }

    async function listCameras() {
      const devices = await navigator.mediaDevices.enumerateDevices();
      const videos = devices.filter(d => d.kind === 'videoinput');
      $selDevice.innerHTML = '';
      videos.forEach((v, i) => {
        const opt = document.createElement('option');
        opt.value = v.deviceId;
        opt.textContent = v.label || `camera ${i+1}`;
        $selDevice.appendChild(opt);
      });
      // í˜„ì¬ íŠ¸ë™ ì„ íƒ ë°˜ì˜
      const s = track?.getSettings?.();
      if (s?.deviceId) $selDevice.value = s.deviceId;
    }

    function camLabelFromSettings(s) {
      const r = `${s.width||'-'}Ã—${s.height||'-'} @${s.frameRate||'-'}fps`;
      return `${s.facingMode||currentFacing} | ${r}`;
    }

    async function startCamera(opts = {}) {
      // ê¸°ë³¸: 640x360 @ 24fps ìš”ì²­ (ë³´ì¥ì€ ì•„ë‹˜)
      const base = {
        width:  { exact: 640 },
        height: { exact: 360 },
        frameRate: { ideal: 24, max: 24 }
      };
      let video = { ...base, facingMode: currentFacing };

      if (opts.deviceId) {
        video = { ...base, deviceId: { exact: opts.deviceId } };
      } else if (opts.facingMode) {
        video = { ...base, facingMode: opts.facingMode };
      }

      // ê¸°ì¡´ ìŠ¤íŠ¸ë¦¼ ì •ë¦¬
      if (stream) stream.getTracks().forEach(t => t.stop());
      stream = await navigator.mediaDevices.getUserMedia({ video, audio: false });
      track = stream.getVideoTracks()[0];
      $preview.srcObject = stream;

      // ì „ë©´ì´ë©´ ë¯¸ëŸ¬ë§
      if ((track.getSettings?.().facingMode || currentFacing) === 'user') $preview.classList.add('mirror');
      else $preview.classList.remove('mirror');

      await listCameras();

      const s = track.getSettings?.() || {};
      $labCamInfo.textContent = camLabelFromSettings(s);
    }

    async function ensureCamera() {
      if (!navigator.mediaDevices?.getUserMedia) {
        throw new Error('getUserMedia ë¯¸ì§€ì› (HTTPS/ë¸Œë¼ìš°ì €/iOS ë²„ì „ í™•ì¸)');
      }
      if (!stream) await startCamera();
    }

    function setWsLabel(txt) { $labWs.textContent = `WS: ${txt}`; }

    const sendQueue = [];
    let sending = false;

    async function sendChunk(buf) {
        sendQueue.push(buf);
        if (sending) return;
        sending = true;

        try {
            while (sendQueue.length && ws && ws.readyState === 1) {
                const chunk = sendQueue[0];

                // ë°±í”„ë ˆì…”: ë²„í¼ê°€ ë‚´ë ¤ê°ˆ ë•Œê¹Œì§€ ì ê¹ì”© ëŒ€ê¸°
                while (ws.bufferedAmount > 1_000_000) {
                await new Promise(r => setTimeout(r, 80));
                $labBuf.textContent = `buffered: ${ws.bufferedAmount}`;
                if (!ws || ws.readyState !== 1) break;
                }
                if (!ws || ws.readyState !== 1) break;

                ws.send(chunk);
                sendQueue.shift();
                $labBuf.textContent = `buffered: ${ws.bufferedAmount}`;
            }
        } finally {
            sending = false;
        }
    }

    function startStreaming() {
        if (!stream) return alert('ë¨¼ì € ì¹´ë©”ë¼ë¥¼ ì‹œì‘í•˜ì„¸ìš”.');
        if (ws && ws.readyState === 1) return; // ì´ë¯¸ ì—°ê²°ë¨

        const mime = pickMime();
        const url  = `ws://${location.hostname}:8000/stream?sid=${encodeURIComponent(sid)}&ext=${encodeURIComponent(currentExt)}`;
        // location.host ëŠ” "hostname:port" í˜•íƒœ (ì˜ˆ: "localhost:8000")
        // const url = `ws://${location.host}/stream?sid=${encodeURIComponent(sid)}&ext=${encodeURIComponent(currentExt)}`;

        
        ws = new WebSocket(url);
        ws.binaryType = 'arraybuffer';

        let pingTimer = null;
        let partCnt = 0, totalBytes = 0;

        ws.onopen = () => {
            setWsLabel('open');

            // 10ì´ˆë§ˆë‹¤ ping (ì„œë²„ëŠ” ë¬¸ìì—´ì€ ë¬´ì‹œ)
            pingTimer = setInterval(() => { try { ws.send('ping'); } catch(_) {} }, 10_000);

            // ì•ˆì •ì„± ìš°ì„  ì‹œì‘ â†’ ì´í›„ ì •ìƒ í™•ì¸ë˜ë©´ ì˜¬ë¦¬ì„¸ìš”(1.5~1.8Mbps / 250ms)
            const opts = mime ? { mimeType: mime, videoBitsPerSecond: 1_200_000 }
                            : { videoBitsPerSecond: 1_200_000 };
            try {
            rec = new MediaRecorder(stream, opts);
            } catch (err) {
            console.error('MediaRecorder init error:', err);
            alert('ë¸Œë¼ìš°ì €ê°€ í•´ë‹¹ ì¸ì½”ë”©ì„ ì§€ì›í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤. ë‹¤ë¥¸ ë¸Œë¼ìš°ì €ë‚˜ í•´ìƒë„/ì½”ë±ì„ ì‹œë„í•˜ì„¸ìš”.');
            return;
            }

            rec.ondataavailable = async (e) => {
            if (!e.data || e.data.size === 0) return;
            partCnt++; totalBytes += e.data.size;
            // console.log(`[REC] #${partCnt} size=${e.data.size} total=${totalBytes}`);
            const buf = await e.data.arrayBuffer();
            if (ws && ws.readyState === 1) {
                await sendChunk(buf);   // ğŸ”´ ë“œë¡­í•˜ì§€ ì•Šê³  í ì „ì†¡
            }
            };

            rec.onerror = (ev) => console.warn('MediaRecorder error', ev.error);

            // 500ms ì¡°ê°(ì•ˆì •ì„±) â†’ OK í™•ì¸ë˜ë©´ 250msë¡œ ë‚®ì¶°ë³´ì„¸ìš”.
            rec.start(500);
            $('btnStopStream').disabled = false;
        };

        ws.onclose = (e) => {
            if (pingTimer) clearInterval(pingTimer);
            setWsLabel('closed');
            if (rec && rec.state !== 'inactive') { try { rec.stop(); } catch(_) {} }
            $('btnStopStream').disabled = true;
            alert(`WebSocket ì¢…ë£Œ: code=${e.code}, reason=${e.reason || '(none)'} wasClean=${e.wasClean}`);
        };

        ws.onerror = (e) => {
            console.error('WS error', e);
            setWsLabel('error');
            alert('WebSocket ì˜¤ë¥˜: ì—°ê²°ì´ ê±°ë¶€ë˜ì—ˆê±°ë‚˜ ì—…ê·¸ë ˆì´ë“œì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. (í˜ì´ì§€/WS í”„ë¡œí† ì½œÂ·í¬íŠ¸ í™•ì¸)');
        };
    }

    function stopStreaming() {
      if (rec && rec.state !== 'inactive') { try { rec.stop(); } catch(_) {} }
      if (ws && ws.readyState <= 1) { try { ws.close(); } catch(_) {} }
      $('btnStopStream').disabled = true;
    }

    // ì´ë²¤íŠ¸ ë°”ì¸ë”©
    $('btnStartCam').onclick = async () => {
      try { await ensureCamera(); }
      catch (e) { alert('ì¹´ë©”ë¼ ì‹œì‘ ì‹¤íŒ¨: ' + e.message); console.error(e); }
    };

    $('btnFront').onclick = async () => {
      try { currentFacing = 'user'; await startCamera({ facingMode: 'user' }); }
      catch (e) { alert('ì „ë©´ ì „í™˜ ì‹¤íŒ¨: ' + e.message); }
    };

    $('btnBack').onclick = async () => {
      try {
        currentFacing = 'environment';
        // ì¼ë¶€ ë¸Œë¼ìš°ì €ëŠ” exactê°€ ì‹¤íŒ¨ â†’ ideal íŒíŠ¸ë¡œ ì¬ì‹œë„
        try { await startCamera({ facingMode: { exact: 'environment' } }); }
        catch { await startCamera({ facingMode: 'environment' }); }
      } catch (e) { alert('í›„ë©´ ì „í™˜ ì‹¤íŒ¨: ' + e.message); }
    };

    $selDevice.onchange = async (e) => {
      try { await startCamera({ deviceId: e.target.value }); }
      catch (ex) { alert('í•´ë‹¹ ì¹´ë©”ë¼ ì„ íƒ ì‹¤íŒ¨: ' + ex.message); }
    };

    $('btnStartStream').onclick = startStreaming;
    $('btnStopStream').onclick = stopStreaming;

    // íƒ­ ë‹«í˜/ìƒˆë¡œê³ ì¹¨ ì‹œ ì •ë¦¬
    window.addEventListener('beforeunload', () => {
      stopStreaming();
      if (stream) stream.getTracks().forEach(t => t.stop());
    });
  </script>
</body>
</html>
